# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_core_dna.ipynb.

# %% auto 0
__all__ = ['taxa_to_filename', 'exists_geno', 'find_geno', 'get_geno', 'list_to_ACGT', 'calc_needed_hilbert_p',
           'np_2d_to_hilbert', 'np_3d_to_hilbert', 'torch_2d_to_hilbert', 'torch_3d_to_hilbert']

# %% ../nbs/02_core_dna.ipynb 10
def taxa_to_filename(taxa = '05-397/250007467', delim = '/'): return(taxa.replace(delim, '__'))

# %% ../nbs/02_core_dna.ipynb 13
def exists_geno(
    taxa, # should be the desired taxa or a regex fragment (stopping before the __). E.g. 'B73' or 'B\d+'
    **kwargs # optionally pass in a genome list (this allows for a different path or precomputing if we're finding a lot of genomes)
             # optionally pass in a different path to the snp table folder
    ):
    if 'genome_files_path' not in kwargs.keys():
        genome_files_path = '../data/zma/g2fc/genotypes/snps/'
    else:
        genome_files_path = kwargs['genome_files_path']
    
    if 'genome_files' not in kwargs.keys():
        import os
        genome_files = os.listdir(genome_files_path)
    else:
        genome_files = kwargs['genome_files']
        
    return(True in [True for e in genome_files if e == taxa])

# %% ../nbs/02_core_dna.ipynb 16
def find_geno(
    taxa, # should be the desired taxa or a regex fragment (stopping before the __). E.g. 'B73' or 'B\d+'
    **kwargs # optionally pass in a genome list (this allows for a different path or precomputing if we're finding a lot of genomes)
             # optionally pass in a different path to the snp table folder
    ):
    "Search for existing marker sets __"
    if 'genome_files_path' not in kwargs.keys():
        genome_files_path = '../data/zma/g2fc/genotypes/snps/'
    else:
        genome_files_path = kwargs['genome_files_path']
    
    if 'genome_files' not in kwargs.keys():
        import os
        genome_files = os.listdir(genome_files_path)
    else:
        genome_files = kwargs['genome_files']
    import re
    return( [e for e in genome_files if re.match(taxa+'__.+', e)] )

# %% ../nbs/02_core_dna.ipynb 18
def get_geno( 
    taxa,
    **kwargs 
    ):
    "Retrieve an existing marker set"
    if 'genome_files_path' not in kwargs.keys():
        genome_files_path = '../data/zma/g2fc/genotypes/snps/'
    else:
        genome_files_path = kwargs['genome_files_path']
        
    with open(genome_files_path+taxa, 'r') as f:
        data = f.read()    
    data = data.split('\t')
    return(data)


# %% ../nbs/02_core_dna.ipynb 29
def list_to_ACGT(
    in_seq, # This should be a list with strings corresponding to IUPAC codes e.g. ['A', 'C', 'Y']
    progress = False
):
    import numpy as np
    import tqdm 
    from tqdm import tqdm

    # Convert IUPAC codes into pr ACGT -------------------------------------------
    encode_dict = {
        #     https://www.bioinformatics.org/sms/iupac.html
        #     A     C     G     T
        'A': [1,    0,    0,    0   ],
        'C': [0,    1,    0,    0   ],
        'G': [0,    0,    1,    0   ],
        'T': [0,    0,    0,    1   ],
        'K': [0,    0,    0.5,  0.5 ],
        'M': [0.5,  0.5,  0,    0   ],
        'N': [0.25, 0.25, 0.25, 0.25],
        'R': [0.5,  0,    0.5,  0   ],
        'S': [0,    0.5,  0.5,  0   ],
        'W': [0.5,  0,    0,    0.5 ],
        'Y': [0,    0.5,  0,    0.5 ],
        #     Other values (assumed empty)
        #     A     C     G     T
         '': [0,    0,    0,    0   ],
        '-': [0,    0,    0,    0   ],
        '0': [0,    0,    0,    0   ],
    }


    # Cleanup -- 
    # Any newlines need to be removed
    in_seq = [e.replace('\n', '') for e in in_seq]

    # Check if there's anything that should be in the dictionary but is not.
    not_in_dict = [e for e in list(set(in_seq)) if e not in list(encode_dict.keys())]

    if not_in_dict != []:
        print("Waring: The following are not in the encoding dictionary and will be set as missing.\n"+str(not_in_dict))

    in_seq = [e if e not in not_in_dict else '' for e in in_seq] 

    # output matrix
    GMat = np.zeros(shape = [len(in_seq), 4])

    # convert all nucleotides to probabilities
    if progress == True:
        for nucleotide in tqdm(encode_dict.keys()):
            mask = [True if e == nucleotide else False for e in  in_seq]
            GMat[mask, :] = encode_dict[nucleotide]    
    else:
        for nucleotide in encode_dict.keys():
            mask = [True if e == nucleotide else False for e in  in_seq]
            GMat[mask, :] = encode_dict[nucleotide]

    return(GMat)


# %% ../nbs/02_core_dna.ipynb 31
def calc_needed_hilbert_p(n_needed = 1048576,
                          max_p = 20):
    out = None
    for i in range(1, max_p):
        if 4**i > n_needed:
            out = i
            break
    return(out)

# %% ../nbs/02_core_dna.ipynb 32
def np_2d_to_hilbert(
    in_seq, # This should be a 2d numpy array with dimensions of [sequence, channels] 
    **kwargs # for silent
):
    import numpy as np
    import tqdm
    from tqdm import tqdm
    
    import hilbertcurve
    from hilbertcurve.hilbertcurve import HilbertCurve
    
    import dataG2F
    from dataG2F.dna import calc_needed_hilbert_p
    
    n_snps = in_seq.shape[0]
    n_channels = in_seq.shape[-1]
    temp = in_seq

    p_needed = calc_needed_hilbert_p(n_needed=n_snps)
    
    # Data represented need not be continuous -- it need only have int positions
    # a sequence or a sequence with gaps can be encoded
    hilbert_curve = HilbertCurve(
        p = p_needed, # iterations i.e. hold 4^p positions
        n = 2    # dimensions
        )

    points = hilbert_curve.points_from_distances(range(n_snps))

    dim_0 = np.max(np.array(points)[:, 0])+1 # add 1 to account for 0 indexing
    dim_1 = np.max(np.array(points)[:, 1])+1
    temp_mat = np.zeros(shape = [dim_0, dim_1, n_channels])
    temp_mat[temp_mat == 0] = np.nan         #  empty values being used for visualization

    if "silent" in kwargs:
        for i in range(n_snps):
            temp_mat[points[i][0], points[i][1], :] = temp[i]
    else:
        for i in tqdm(range(n_snps)):
            temp_mat[points[i][0], points[i][1], :] = temp[i]

    return(temp_mat)

# %% ../nbs/02_core_dna.ipynb 33
def np_3d_to_hilbert(
    in_seq, # This should be a 3d numpy array with dimensions of [samples, sequence, channels] 
    **kwargs
):
    "This is the 3d version of `np_2d_to_hilbert`. The goal is to process all of the samples of an array in one go."
    import numpy as np
    import tqdm
    from tqdm import tqdm
    
    import hilbertcurve
    from hilbertcurve.hilbertcurve import HilbertCurve

    import dataG2F
    from dataG2F.dna import calc_needed_hilbert_p
    
    n_snps = in_seq.shape[1]
    n_channels = in_seq.shape[-1]
    temp = in_seq

    p_needed = calc_needed_hilbert_p(n_needed=n_snps)
    
    # Data represented need not be continuous -- it need only have int positions
    # a sequence or a sequence with gaps can be encoded
    hilbert_curve = HilbertCurve(
        p = p_needed, # iterations i.e. hold 4^p positions
        n = 2    # dimensions
        )

    points = hilbert_curve.points_from_distances(range(n_snps))

    dim_0 = np.max(np.array(points)[:, 0])+1 # add 1 to account for 0 indexing
    dim_1 = np.max(np.array(points)[:, 1])+1
    temp_mat = np.zeros(shape = [in_seq.shape[0], dim_0, dim_1, n_channels])
    temp_mat[temp_mat == 0] = np.nan         #  empty values being used for visualization
    
    if "silent" in kwargs:
        for i in range(n_snps):
            temp_mat[:,                          # sample
                     points[i][0], points[i][1], # x, y
                     :] = temp[:, i]             # channels
    else:
        for i in tqdm(range(n_snps)):
            temp_mat[:,                          # sample
                     points[i][0], points[i][1], # x, y
                     :] = temp[:, i]             # channels

    return(temp_mat)

# %% ../nbs/02_core_dna.ipynb 34
def torch_2d_to_hilbert(
    in_seq, # This should be a 2d numpy array or torch tensor with dimensions of [sequence, channels] 
    **kwargs # for verbose
):
    import numpy
    import torch
    import tqdm
    from tqdm import tqdm
    
    import hilbertcurve
    from hilbertcurve.hilbertcurve import HilbertCurve
    
    import dataG2F
    from dataG2F.dna import calc_needed_hilbert_p

    if isinstance(in_seq, numpy.ndarray):
        in_seq = torch.from_numpy(in_seq)
    
    n_snps = in_seq.shape[0]
    n_channels = in_seq.shape[-1]
    temp = in_seq

    p_needed = calc_needed_hilbert_p(n_needed=n_snps)
    
    # Data represented need not be continuous -- it need only have int positions
    # a sequence or a sequence with gaps can be encoded
    hilbert_curve = HilbertCurve(
        p = p_needed, # iterations i.e. hold 4^p positions
        n = 2    # dimensions
        )

    points = hilbert_curve.points_from_distances(range(n_snps))

    dim_0 = torch.Tensor(points)[:, 0].max()+1 # add 1 to account for 0 indexing
    dim_1 = torch.Tensor(points)[:, 1].max()+1
    temp_mat = torch.zeros((dim_0.int().item(), # convert to int, get item
                            dim_1.int().item(), 
                            n_channels))
    temp_mat[temp_mat == 0] = torch.nan         #  empty values being used for visualization

    verbose = False
    if 'verbose' in kwargs:
        if kwargs['verbose'] == True:
            verbose = True

    if verbose:
        for i in tqdm(range(n_snps)):
            temp_mat[points[i][0], points[i][1], :] = temp[i] 
    else:        
        for i in range(n_snps):
            temp_mat[points[i][0], points[i][1], :] = temp[i]
    return(temp_mat)

# %% ../nbs/02_core_dna.ipynb 35
def torch_3d_to_hilbert(
    in_seq, # This should be a 3d numpy array with dimensions of [samples, sequence, channels] 
    **kwargs
):
    "This is the 3d version of `torch_2d_to_hilbert`. The goal is to process all of the samples of an array in one go."
    # import numpy as np
    import numpy
    import torch
    import tqdm
    from tqdm import tqdm
    
    import hilbertcurve
    from hilbertcurve.hilbertcurve import HilbertCurve

    import dataG2F
    from dataG2F.dna import calc_needed_hilbert_p
    
    n_snps = in_seq.shape[1]
    n_channels = in_seq.shape[-1]
    temp = in_seq

    p_needed = calc_needed_hilbert_p(n_needed=n_snps)
    
    # Data represented need not be continuous -- it need only have int positions
    # a sequence or a sequence with gaps can be encoded
    hilbert_curve = HilbertCurve(
        p = p_needed, # iterations i.e. hold 4^p positions
        n = 2    # dimensions
        )

    points = hilbert_curve.points_from_distances(range(n_snps))

    # dim_0 = np.max(np.array(points)[:, 0])+1 # add 1 to account for 0 indexing
    # dim_1 = np.max(np.array(points)[:, 1])+1
    # temp_mat = np.zeros(shape = [in_seq.shape[0], dim_0, dim_1, n_channels])
    # temp_mat[temp_mat == 0] = np.nan         #  empty values being used for visualization
    
    dim_0 = torch.Tensor(points)[:, 0].max()+1 # add 1 to account for 0 indexing
    dim_1 = torch.Tensor(points)[:, 1].max()+1
    temp_mat = torch.zeros((in_seq.shape[0], 
                            dim_0.int().item(), # convert to int, get item
                            dim_1.int().item(), 
                            n_channels))
    temp_mat[temp_mat == 0] = torch.nan         #  empty values being used for visualization

    verbose = False
    if 'verbose' in kwargs:
        if kwargs['verbose'] == True:
            verbose = True

    if verbose:
        for i in tqdm(range(n_snps)):
            temp_mat[:,                 # sample
            points[i][0], points[i][1], # x, y
            :] = temp[:, i]             # channels
    else:        
        for i in range(n_snps):
            temp_mat[:,                 # sample
            points[i][0], points[i][1], # x, y
            :] = temp[:, i]             # channels

    return(temp_mat)
